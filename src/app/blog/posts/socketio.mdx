---
title: "Real-time Applications with Node.js and WebSockets (Socket.io)"
summary: "Learn how to build real-time applications with Node.js and WebSockets using Socket.io. We'll demonstrate with a live chat app built in ReactJS and discuss use cases like dashboards and notifications."
publishedAt: "2025-04-16"
tag: "Node.js"
---

# Real-time Applications with Node.js and WebSockets (Socket.io)

Traditional HTTP is request-response based, which means the server canâ€™t push updates to the client unless the client asks for them. **WebSockets** solve this by creating a persistent two-way connection between client and server.  

With **Socket.io**, building real-time apps in Node.js becomes easier. Letâ€™s walk through building a simple **chat application** with a **ReactJS frontend** and explore other real-time use cases.  

---

## 1. âš¡ Why Real-time Applications?

Real-time apps are everywhere:  
- ðŸ’¬ Chat applications (WhatsApp, Slack, Discord)  
- ðŸ“Š Live dashboards (stocks, analytics, IoT data)  
- ðŸŽ® Multiplayer games  
- ðŸ”” Real-time notifications  

---

## 2. ðŸ”Œ Setting up a WebSocket Server with Socket.io

Install dependencies:

```bash
npm install express socket.io
```

**Server code:**
```js
// server.js
const express = require("express");
const http = require("http");
const { Server } = require("socket.io");

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: "http://localhost:5173", // React app port (e.g., Vite default)
    methods: ["GET", "POST"],
  },
});

io.on("connection", (socket) => {
  console.log("A user connected");

  socket.on("chat message", (msg) => {
    console.log("Message received:", msg);
    io.emit("chat message", msg); // broadcast to all clients
  });

  socket.on("disconnect", () => {
    console.log("A user disconnected");
  });
});

server.listen(3000, () => {
  console.log("Server running on http://localhost:3000");
});
```
---

## 3. ðŸ’» ReactJS Frontend with Socket.io Client
**Install client library:**

```bash
npm install socket.io-client
```

**React component:**
```jsx
// ChatApp.jsx
import React, { useEffect, useState } from "react";
import { io } from "socket.io-client";

const socket = io("http://localhost:3000");

export default function ChatApp() {
  const [message, setMessage] = useState("");
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    socket.on("chat message", (msg) => {
      setMessages((prev) => [...prev, msg]);
    });

    return () => {
      socket.off("chat message");
    };
  }, []);

  const sendMessage = (e) => {
    e.preventDefault();
    if (message.trim()) {
      socket.emit("chat message", message);
      setMessage("");
    }
  };

  return (
    <div className="chat-app">
      <h2>ðŸ’¬ Real-time Chat</h2>
      <ul>
        {messages.map((msg, idx) => (
          <li key={idx}>{msg}</li>
        ))}
      </ul>
      <form onSubmit={sendMessage}>
        <input
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="Type a message..."
        />
        <button type="submit">Send</button>
      </form>
    </div>
  );
}
```

---

## 4. ðŸ“Š Beyond Chat: Real-time Dashboards
Socket.io isnâ€™t just for chat â€” itâ€™s also great for live dashboards.

**Example: broadcasting CPU usage to all clients every second:**
```js
// In server.js
setInterval(() => {
  const cpuUsage = Math.random() * 100; // mock data
  io.emit("cpu update", cpuUsage);
}, 1000);
```

**React client listens for updates:**
```jsx
// CpuDashboard.jsx
import React, { useEffect, useState } from "react";
import { io } from "socket.io-client";

const socket = io("http://localhost:3000");

export default function CpuDashboard() {
  const [usage, setUsage] = useState(0);

  useEffect(() => {
    socket.on("cpu update", (val) => {
      setUsage(val.toFixed(2));
    });

    return () => socket.off("cpu update");
  }, []);

  return (
    <div>
      <h2>ðŸ“Š CPU Usage</h2>
      <p>{usage}%</p>
    </div>
  );
}
```

---

## ðŸ”’ Best Practices
- Namespaces & Rooms â€“ Organize sockets for different features/channels.
- Authentication â€“ Use JWT or session tokens to authenticate socket connections.
- Scalability â€“ Use Redis or Kafka with socket.io-redis for multi-server setups.
- Error handling â€“ Always handle disconnects, reconnections, and retries.
- Security â€“ Validate all incoming events, rate-limit messages, and enable CORS rules.

---

## ðŸš€ Key Takeaways
- Socket.io + ReactJS makes building real-time apps simple and modern.
- Great for chat apps, dashboards, notifications, and multiplayer games.
- Use namespaces, rooms, and external message brokers for scalability.
- Secure your sockets with authentication and rate limiting.

Real-time features are expected in modern apps. With Node.js, Socket.io, and ReactJS, you can deliver them effectively.